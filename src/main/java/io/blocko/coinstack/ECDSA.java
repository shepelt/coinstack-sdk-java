package io.blocko.coinstack;

import java.io.IOException;
import java.security.SignatureException;

import org.bitcoinj.core.AddressFormatException;
import org.bitcoinj.core.DumpedPrivateKey;
import org.bitcoinj.core.ECKey;
import org.bitcoinj.params.MainNetParams;
import org.bitcoinj.params.RegTestParams;

import io.blocko.coinstack.exception.MalformedInputException;

/**
 * ECDSA algorithm implementation. Signing message with private key
 * verify signature with Bitcoin address which is derived from ECDSA public key
 */
public class ECDSA {
	
	/**
	 * Sign message text with private key, producing signature
	 * Signature will be verified later with verifyMessageSignature method
	 * This method is only used for Mainnet
	 * @param privateKeyWIF
	 *            ECDSA private key with WIF form which is originally
	 *            generated from ECKey class 
	 * @param messageText
	 *            Text message that will be signed with private key
	 * @return Signature generated, it will be verified with verifyMessageSignature method
	 * 
	 * @throws MalformedInputException
	 *            Invalid private key        	           
	 */
	public static String signMessage(String privateKeyWIF, String messageText) throws MalformedInputException {
		return signMessage(privateKeyWIF, messageText, true);
	}
	
	/**
	 * Sign message text with private key, producing signature
	 * Signature will be verified later with verifyMessageSignature method
	 * This method is used for either Mainnet or Testnet
	 * 
	 * @param privateKeyWIF
	 *            ECDSA private key with WIF form which is originally
	 *            generated from ECKey class 
	 * @param messageText
	 *            Text message that will be signed with private key
	 * @param isMainNet
	 *            True is Mainnet, false is Testnet
	 * @return Signature generated, it will be verified with verifyMessageSignature method
	 * 
	 * @throws MalformedInputException
	 *            Invalid private key        	           
	 */
	public static String signMessage(String privateKeyWIF, String messageText, boolean isMainNet) throws MalformedInputException {
		ECKey eckey = null;
		String signature = null;

		try {
			if (isMainNet) {
				eckey = new DumpedPrivateKey(MainNetParams.get(), privateKeyWIF).getKey();
			} else {
				eckey = new DumpedPrivateKey(RegTestParams.get(), privateKeyWIF).getKey();
			}
		} catch (AddressFormatException e) {
			throw new MalformedInputException("Invalid private key", "Parsing private key failed");
		}

		signature = eckey.signMessage(messageText);
		return signature;
	}

	/**
	 * verify signature which is originally generated by signMessage method
	 * with Bitcoin address and original message
	 * This method is only used for Mainnet 
	 * 
	 * @param address
	 *            Bitcoin address derived from ECDSA public key            
	 * @param messageText
	 *            Text message that was signed with private key
	 * @param signature
	 *            Signature generated by signMessage method
	 * @return boolean
	 */
	public static boolean verifyMessageSignature(String address, String messageText, String signature) {
		return verifyMessageSignature(address, messageText, signature, true);
	}

	/**
	 * verify signature which is originally generated by signMessage method
	 * with Bitcoin address and original message
	 * This method is used for either Mainnet or Testnet
	 * 
	 * @param address
	 *            Bitcoin address derived from ECDSA public key            
	 * @param messageText
	 *            Text message that was signed with private key
	 * @param signature
	 *            Signature generated by signMessage method
	 * @return boolean
	 */
	public static boolean verifyMessageSignature(String address, String messageText, String signature,
			boolean isMainNet) {
		ECKey originalKey = null;
		String derivedAddress = null;
		try {
			originalKey = ECKey.signedMessageToKey(messageText, signature);
		} catch (SignatureException e) {
			return false;
		}

		if (isMainNet) {
			derivedAddress = originalKey.toAddress(MainNetParams.get()).toString();
		} else {
			derivedAddress = originalKey.toAddress(RegTestParams.get()).toString();
		}

		if (address.equals(derivedAddress))
			return true;
		else
			return false;
	}
}
